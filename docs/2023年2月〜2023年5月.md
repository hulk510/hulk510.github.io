# プロジェクト名

- 通話アプリからスレッド機能へのピボット開発

## プロジェクトの詳細

アプリStayONの通話機能主体からスレッド機能へと変換する開発。

<img src="https://i.gyazo.com/4e151a2a2a49de45a1469d1ee145f5a2.png" width="150rem" />
<img src="https://i.gyazo.com/cf905a297f8b696242eb339fe830b741.jpg" width="150rem" />
<img src="https://i.gyazo.com/eb770fb6355ad5a12ff6829f76758171.png" width="150rem" />
<img src="https://i.gyazo.com/a63aa2c743524a4e041c65d9e477fdb0.gif" width="150rem" />

## 使用技術

- Dynamic Links
- Firebase Cloud Messaging
- Firestore
- Cloud Function
- SwiftUI

## 参加期間

- 2023年2月~2023年5月

## 開発規模

- 4人
  開発は1人

## プロジェクトでの課題

通話アプリの検証結果として、コミュニケーションをするにあたって予想以上に通話そのものがハードルになっていた。通話だとサービスが始まってすぐの少ない期間に他のユーザーが居なくて通話出来なかったり、通話をしても話せる話題が出にくいなど同期的なコミュニケーションを快適に取る事が出来てなかった。
そのため、コミュニケーションの形をテキストにして非同期でも会話可能な状態へと変える必要があった。

## 主な取り組み

### トピックで話せるスレッド機能への移行

アプリの主要機能を通話からテキストでのチャットを行う形に変更するため新規開発をしました。
移行をするにあたって以下のことを実施・実装しました。

#### 不要なコードの削除

通話機能削除に合わせて、画面共有に使っていたコードやコードで使わなくなった通話機能などを全て削除することから始めました。残しておくことも出来たが、後から参加した人は分からないし結局その部分を理解するのに負荷がかかるため、そして自分が見てもノイズになるため思い切って全部削除しました。Swiftだと定義されてない関数や変数があるとコンパイルエラーになるため、viewModelなど大元を全て削除してエラーが出た部分を全て削除していった。

#### カテゴリーの作成と自動割り振り

まず、スレッド機能の実現にあたってカテゴリでの絞り込みや分類、Twitter、 NewsAPIでの自動スレッド作成などAPIの使い方から進めました。スレッド自体はFirestoreで完結する物だったので、まだ未知数な部分の実装を先に行うと後が楽だと考えたためです。
カテゴリーはFirestoreのin句を使った絞り込みを行う設計にして、複数選択可能で選択した際にor検索する予定でした。

アプリ内で使用するカテゴリーはGoogleのNatural Language APIの分類リストから使う物をピックアップして使いました。Natural Language APIの採用理由としては一定リクエスト無料な事、Twitterのトレンドツイートからスレッドを作成する時にカテゴリ分類を自動で選択できると判断したからです。また、Firestoreの仕様上、検索に使えるカテゴリーは10個しか使えないため10個に抑える必要があり、APIの分類リストだと多すぎたためピックアップしました。
APIから返却されるリストの大カテゴリだけでも数が多く、使うカテゴリを絞る事に苦労しました。そのため使うカテゴリーを選ぶ際は、スプレッドシートでまとめた方が分かりやすいカテゴリーはマージ、いらないカテゴリーをその他に分けてアプリで使う10個のカテゴリを決めました。その際、どれがアプリにあると絞り込みやすいかなどを相談しながら決めていきました。
表示で使うFirestoreのカテゴリードキュメントの登録は人力でやると時間がかかるのとEmulatorでテストして本番に反映するとき同じことをやる必要があり大変なためAdminSDKを使い一括で作れるようにしました。APIのカテゴリとFirestoreのカテゴリをマッピングして配列で一覧を保持してAPIのカテゴリからドキュメントを検索できるようにしたデータ登録するスクリプトを書き登録を自動化しました。

実装では、文章をAPIに渡し返却されるカテゴリ候補から一番有力なカテゴリの大カテゴリだけを抽出するロジックを書き、Firestoreからarray-containsでAPIカテゴリ名を使って取得できるようにしました。そして、スレッド作成時にIDを紐づけをすることで記事を作成する際にカテゴリの割り振りを自動で行えるようにしました。苦労した点としては、EmulatorだとNatural Language APIがPermissionエラーで実行できない事でした。Emulator内部からAPIキーを使って、Twitterのアクセスなどは行えていましたがNaturalLanguageAPIだけ権限エラーで実行できていませんでした。AdminSDKとCloudFunctionでserviceAccountのキーを使う必要があったりなかったりとGCPのサービスを使うときの権限が良くわかっていなかったためIAMの調査をしました。アクセス元がGCPのサービスであれば必要ないことが分かったため、ローカルで使うためには自分が誰なのかを指定する必要があると気づき、サービスアカウントのキーを作成して実行時に使うことでAPIを使うことができました。

#### Twitter、NewsAPIから話題の取得とスレッド自動作成

NewsAPIとTwitter APIを使って記事やトレンドツイートを取得しスレッドを作成する処理とPubsubを使ってその処理を一定間隔で自動発火するようにしました。スレッドには話題となるトピックが必要になるため、初期の時点ではユーザー自身が作成することは少ないため話題がいくつかある状態にして会話に移らせることが狙いでした。そのため、トピックに出来そうなAPIを探しました。APIを使って自動で作成できるようにしておくことで、運用でスレッドを作る手間を省ける意図もあったため何かしらのAPIを使った実装が必要とチーム内で判断しました。その中でニュース記事やTwitterのトレンドで今の話題を取得する事が可能になると考え、それらのAPIの利用を提案して実装しました。
NewsAPIは非公式のライブラリを使い実装しました。Axiosなどのクライアントは実装がめんどくさかったことと型指定などがすでにされていたためライブラリを使用しました。ライブラリを使って処理部分と記事作成部分を分けて処理を作成する事で今後APIを使うときに取得部分をそのまま使いまわせられるようにしました。そして引数に記事数を指定し記事カテゴリー毎に3件の記事を取得してその結果から記事を作成する関数を実装しました。
NewsAPIで使うカテゴリもNatural Language APIと同様にFIrestoreのフィールドに保存しておいてそこから検索できるようにしてカテゴリーのIDの紐づけを行いました。
TwitterAPIでも非公式ライブラリを使用してトレンドからツイートを取得する処理を書いて、ツイートの本文を合算してNatural Language APIでカテゴリを分類した上でスレッドを作成しました。公式ライブラリだとv2エンドポイントの型のみ記載されていてv1.1の型がなかったため非公式のライブラリを使用しました。
ツイートの取得にはAPI権限が必要だったりとAPIを理解していなかったため、まずDiscordに送信する形でTwitterのsdkを試しながらトレンドの取得と取得したトレンドからツイートを取得する処理を実装しました。
[その時作ったコード](https://github.com/hulk510/torendo-hoshi)
Discordのライブラリもjavascriptで書けるため移行がしやすいと考え、アプリで実装するよりもAPIの使い方や仕様を理解できるようにGASで使いたいAPIの処理やロジックを構築しました。
NewsAPI、TwitterAPIからスレッドを作成する機能ができた段階でPubSubの関数を作成して一定間隔で自動発火するように設定した後はユーザーの記事作成とシェア機能のディープリンクを実装しました。

#### スレッドの新規作成とシェア機能のディープリンク対応

新規作成画面では、スレッドの画像選択としてiOS16から使えるようになったPhotosPickerを使用して画像の取得と選択ができるようにしました。登録した画像はFirestoreのStorageに保存していたのですが、帯域の料金が思った以上に増えていたためKingfisherを入れてキャッシュしたものを取得・表示するようにして帯域を節約できるようにしました。
次に、Firebaseで作成したDynamicLinkからアプリをインストールしていたら該当のスレッドに遷移できるようにディープリンク対応をしました。元々DynamicLinksでディープリンク自体は作成していたのですが、開いて遷移させる部分の実装があまりよくわかっていなかったこと、ディープリンクを開いて遷移させる方法が分からなかったため遷移は実装していませんでした。NavigationStackに関してもiOS16で使いやすくなったためアプリ内の共通の遷移を一元化できるようにしておりディープリンクを扱いやすくなったと判断したため実装しました。
[その時作成した記事](https://zenn.dev/hulk510/articles/swiftui-navigation-stack)

ディープリンク対応では、Webの記事を参考にした時書かれていたapplicationメソッドでの方法だと動かなくて詰まっていました。そのため、StackOverflowなど参考にしてopenURLで指定のURLなら特定のnavigationDestinationに送ることでページ遷移を実装しました。

#### スレッドの制限時間・アーカイブ機能

最後に、スレッドの時間制限機能と時間になったらアーカイブする機能を実装しました。アーカイブを実装した経緯としては、自動作成されたスレッドやユーザーのスレッドが残り続けると新しいスレッドを探しづらいのと、スレッドが消えるのを阻止するためコメントを定期的に行わせるようにするためでした。
アーカイブ機能ではアーカイブする日付をスレッド作成時に1日後で登録し、コメントされたタイミングでバックエンド関数が発火し24時間を上限に指定時間伸ばす実装をしました。実装する際は、Github Copilotを使用して大まかなロジックの概要を作成し、それらを整理しながら実装する事で時間短縮が出来ました。

#### お知らせ機能の実装

お知らせ画面ではスレッドでコメントが来た時や返信が来た時の通知を表示できる画面を作成しました。通知に表示するデータのタイプが複数考えられたため表示する要素のprotocolを定義して、スレッドのお知らせ、返信のお知らせなど異なるデータでもprotocolに準拠していれば処理できるようにしてみました。
あまりprotocolを必要とする場面がなかったため実装してなかったのですが、お知らせを取得する際、色々なデータ構造をすべて1つのドキュメントに保存するのがあまりイケてないと感じたためそうしました。
また、お知らせ画面の実装に合わせてバックエンドから端末にプッシュ通知を送る処理を変更しました。アプリ、バックエンド両側で処理を作成していましたが非推奨なやり方になったことで変える必要があったため、通知の処理をバックエンドでまとめられるように変更しました。実装後はCloudFunctionのonCallメソッドを呼び出す構造体を定義して通知の具体的な処理はバックエンドで行えるようにしたことでアプリ側での処理が簡潔にできました。

## 振り返り

スレッドでのやり取りに変え、Twitter運用などマーケティングをする人が頑張ってくれたおかげで一時はアプリランキングで175位とランキングに載る事が出来た。
APIを使う事で簡単にアプリ機能の幅を持たせる事ができ、よりリッチな機能を開発できたため楽しかった。また、その実現にCopilotを個人的に導入したことで開発がやりやすくなった。全てを任せるという事はできなかったが、実装したい事に沿って提案をしてくれるため迅速に開発できる実感があり開発を楽しくできた。
iOS16が使えるようになり使いやすいメソッドなどが増えた時も何か使えそうなのがないか調べることでディープリンクの実装が簡単に行えるようになったりと個人的にキャッチアップしていた事が開発に活かすことができたと考えている。
